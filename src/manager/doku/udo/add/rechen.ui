##############################################################
!node Rechenbefehle

##############################################################
!subnode ABS

Berechnet den absoluten Wert einer Zahl. Der absolute Wert einer Zahl ist
deren Betrag und stets positiv.

(!U)Syntax:(!u) (!nl)
Ergebnis=ABS(Wert);

Wert ist eine beliebige Zahl (Konstante, Flieûkomma- oder Zahlenfeld,
Variable).

(!I)Beispiel:(!i) (!nl)
ABS(4,6) ergibt 4,6 (!nl)
ABS(-24) ergibt 24 (!nl)
ABS(0) ergibt 0 (!nl)

##############################################################
!subnode ACOS

Berechnet den Arcuscosinus einer Zahl. Ist die Umkehrfunktion zu COS.

(!U)Syntax:(!u) (!nl)
Ergebnis = ACOS(Wert);

Wert ist eine beliebige Zahl (Konstante, Flieûkomma- oder Zahlenfeld,
Variable). ACOS erwartet einen Wert im Bereich von -1..+1 und liefert den
dazugehîrigen Winkel in der Einheit rad zurÅck.

(!I)Beispiel:(!i) (!nl)
ACOS(-0,678) ergibt 2,315835

##############################################################
!subnode Alert

Diese Funktion gibt eine Alertbox (Warnungsbox) mit Informationen fÅr den
Benutzer auf dem Bildschirm aus. In einer Alertbox kînnen bis zu vier
Textzeilen ausgegeben werden. Dieser Text kann mit einem von 4 Icons
kombiniert werden. (!nl)
Auûerdem kînnen auf einer Alertbox bis zu fÅnf Knîpfe dargestellt werden.
Als Ergebnis erhÑlt man die Nummer des angeklickten Knopfes zurÅck, wobei
die Knîpfe von links mit 1 beginnend durchnumeriert sind.

(!U)Syntax:(!u) (!nl)
Ergebnis=ALERT("[Piktogramm][Text][Buttons][Pattern][Hilfe]");

Zur ErlÑuterung der einzelnen Parameter:

Piktogramm legt das Piktogramm fest, das auf der linken Seite der Box
erscheinen soll: (!nl)
0 = Infosymbol, (!nl)
1 = Ausrufezeichen, (!nl)
2 = Fragezeichen, (!nl)
3 = Stoppschild. (!nl)
4 = kein Piktogramm

Die Nummer ist in eckige Klammern einzuschlieûen.

(!B)Text(!b) steht fÅr beliebigen Text. Es sind maximal 4 Zeilen † 40 Zeichen
darstellbar. Die einzelnen Zeilen sind durch einen senkrechten Strich ("|")
voneinander zu trennen. Der Text ist in eckige Klammern einzuschlieûen.

(!B)Buttons(!b) dient zur Festlegung der Knîpfe, mit denen die Box verlassen
werden kann. Es sind maximal 5 Knîpfe mîglich. Die Knopfbezeichnungen sind
wieder durch senkrechte Striche ("|") voneinander zu trennen.
Soll ein Knopf per Tastatur bedienbar sein (Alternate-Buchstabe), ist vor
dem entsprechenden Buchstaben eine Tilde (~) einzufÅgen.

(!B)Pattern(!b) ordnet den Knîpfen eine bestimmte Bedeutung zu und kann wahlweise
fÅr das Ertînen eines Glockensignals beim ôffnen der Box sorgen.
Dabei gilt folgende Reihenfolge: (!nl)
[Glocke|Nr.OK-Knopf|Nr.Abbruch-Knopf|Nr.Hilfe-Knopf ]. (!nl)

Wird fÅr (!B)Glocke(!b) 1 angegeben, ertînt ein Glockenton, bei 0 nicht. (!nl)
In den
anderen drei Feldern ist anzugeben, welche der Knîpfe die Bedeutung des
OK-, Abbruch- oder Hilfe-Knopfes erhalten sollen. Dabei sind die Knîpfe
von links mit 1 beginnend durchnumeriert. (!nl)
Soll keine Standardbedeutung zugeordnet werden, muû "-1" angegeben werden.

(!B)help(!b) enthÑlt einen Verweis auf den Eintrag in der Hilfedatenbank, zu dem
bei BetÑtigen des als Hilfe-Knopf definierten Buttons Informationen
angezeigt werden sollen. Beachten Sie das es sich bei der Hilfe nicht um die des
Manager handelt, sondern um die speziell zur Datenbank zu erstellende.

Wenn Sie hier kein Zeichen angeben, wird nicht in
die Hilfedatenbank verzweigt. Da Sie die Hilfedatenbanken selbst
modifizieren kînnen (siehe Anhang A im PHOENIX-Handbuch), kînnen Sie Åber
diesen Eintrag Informationen zur aktuellen Rechnung oder Datenbank
anzeigen.

(!I)Beispiel:(!i) (!nl)
!begin_verbatim
a)
  VAR b;
  b=ALERT("[3][Zeile1|Zeile2][Knopf ~1|Knopf ~2][0|1|1|-1][]");
b)
  VAR b;
  b=ALERT("[1][Standardknîpfe][OK|Abbruch|Hilfe][1|1|2|3][Index]");
!end_verbatim
Ein Klick auf "Hilfe" zeigt den Index der Online-Hilfe an.

##############################################################
!subnode ASIN

Berechnet den Arcussinus einer Zahl. Ist die Umkehrfunktion zu SIN.

(!U)Syntax:(!u) (!nl)
Ergebnis=ASIN(Wert);

Wert ist eine beliebige Zahl (Konstante, Flieûkomma- oder Zahlenfeld,
Variable). (!nl)
ASIN erwartet einen Wert im Bereich von -1..+1 und liefert den
dazugehîrigen Winkel in der Einheit rad zurÅck.

(!I)Beispiel:(!i) (!nl)
ASIN(0,543) ergibt 0,574006

##############################################################
!subnode ATAN

Berechnet den Arcustangens einer Zahl. Ist die Umkehrfunktion zu TAN.

(!U)Syntax:(!u) (!nl)
Ergebnis=ATAN(Wert); Wert ist eine beliebige Zahl (Konstante, Flieûkomma-
oder Zahlenfeld, Variable). (!nl)
ATAN erwartet einen beliebigen Wert und liefert den dazugehîrigen Winkel
in der Einheit rad zurÅck.

(!I)Beispiel:(!i) (!nl)
ATAN(456,78) ergibt 0,574006

##############################################################
!subnode AVG

Ermittelt fÅr alle DatensÑtze der Zieltabelle, die mit einem bestimmten
Index abgelegt wurden, den Durchschnitt eines beliebigen Feldes.

(!U)Syntax:(!u) (!nl)
Ergebnis=AVG("Feldname;Quellindex>ZIELTABELLE.Zielindex");

Feldname ist das Feld der ZIELTABELLE, fÅr das der Durchschnitt ermittelt
werden soll.

(!I)Beispiel:(!i) (!nl)
siehe MAX

##############################################################
!subnode CHAR

Wandelt einen Wert in eine Zeichenkette um.

(!U)Syntax:(!u) (!nl)
Ergebnis=CHAR(Wert);

Wert ist eine beliebige Zahl (Konstante, Flieûkomma- oder Zahlenfeld,
Variable).

(!U)Beispiele:(!u) (!nl)
CHAR(123,45) erzeugt die Zeichenkette "123,45" (!nl)
CHAR(51) erzeugt die Zeichenkette "51".

##############################################################
!subnode CHR

Wandelt eine Zahl zwischen 0 und 255 in den dazugehîrenden ASCII-Wert.

(!U)Syntax:(!u) (!nl)
Ergebnis=CHR(Wert);

Wert ist eine Zahl zwischen 0 und 255.

(!I)Beispiel:(!i) (!nl)
CHR(65) erzeugt das Zeichen "A" (!nl)
CHR(13)+CHR(10) erzeugt die (sonst nicht direkt eingebbare) Zeichenkette
"Carriage return/Line feed", also einen Zeilenvorschub.

##############################################################
!subnode COS

berechnet den Cosinus einer Zahl.

(!U)Syntax:(!u) (!nl)
Ergebnis=COS(Wert);

Wert ist eine beliebige Zahl (Konstante, Flieûkomma- oder Zahlenfeld,
Variable). COS erwartet einen Wert in der Einheit rad (0 Grad=0pi, 90
Grad=pi/2, 180 Grad=pi, 270 Grad=3pi/2, 360 Grad=2pi usw.) als Argument und
liefert den dazugehîrigen Cosinus zurÅck.

(!I)Beispiel:(!i) (!nl)
COS(3,141) ergibt -1,0

##############################################################
!subnode COUNT

COUNT liefert die Nummer des aktuellen Datensatzes und wird wÑhrend des
Rechenprozesses datensatzweise inkrementiert.

(!U)Syntax und Beispiel:(!u) (!nl)
Nummer=COUNT;

Damit kînnen die DatensÑtze einer Tabelle automatisch durchnumeriert
werden, im Feld Nummer steht am Ende die Datensatznummer.

##############################################################
!subnode DATE

Konvertiert eine Zeichenkette in ein Datumsfeld.

(!U)Syntax:(!u) (!nl)
Datumsfeld=DATE(Zeichenkette);

##############################################################
!subnode DAY

Ermittelt aus einem gegebenen Datumsfeld den Tag.

(!U)Syntax:(!u) (!nl)
Tag=DAY(Datumsfeld)

##############################################################
!subnode ERRNO

Liefert den Status der letzten Rechenoperation.

(!U)Syntax:(!u) (!nl)
Ergebnis=ERRNO();

Wenn bei der letzten Rechenoperation ein Fehler aufgetreten ist, liefert
diese Funktion einen positiven Fehlercode, ansonsten die Zahl 0.

Dabei bedeuten: (!nl)
Fehlercode 33: Argument auûerhalb des zulÑssigen Rechenbereiches. (!nl)
Fehlercode 34: Ergebnis auûerhalb des zulÑssigen Rechenbereiches.

Auûerdem liefert die jeweilige Rechenfunktion als Ergebnis 0,0.

(!I)Beispiel:(!i)
!begin_verbatim
VAR b,x;
x=SQRT(-1);
IF ERRNO<>0 THEN
    b=ALERT("[3][Fehler!][~Abbruch][0|1|1|-1][]");
END;
!end_verbatim

##############################################################
!subnode EXIT

Ermîglicht das vorzeitige Beenden einer Rechnung.

(!U)Syntax:(!u) (!nl)
EXIT;

(!I)Beispiel:(!i)
!begin_verbatim
...
button=ALERT(...);
IF button==! THEN
    EXIT;
END;
...
!end_verbatim

##############################################################
!subnode EXP

Exponentialfunktion, berechnet e^x, wobei e fÅr die Basis des natÅrlichen
Logarithmus steht (2,718281...).

(!U)Syntax:(!u) (!nl)
Ergebnis=EXP(Wert);

Wert ist eine beliebige Zahl (Konstante, Flieûkomma-oder Zahlenfeld,
Variable).

(!I)Beispiel:(!i) (!nl)
EXP(2,0) (!nl)
ergibt 7,389056

##############################################################
!subnode EXPORT

Der Inhalt eines beliebigen Feldes (Text, Zahl, Grafik, BLOB...) wird
in einer Datei gespeichert.

(!U)Syntax:(!u) (!nl)
Ergebnis=EXPORT(Dateiname,Feldname);
!begin_xlist [Dateiname] !short
  !item [Dateiname] sollte einen vollstÑndigen Zugriffspfad inklusiv
        Laufwerksbuchstaben enthalten.
  !item [Feldname] kann ein beliebiges Feld sein.
!end_xlist

(!U)Ergebnis(!u)
!begin_verbatim
  0  OK
  1  Datei existiert nicht
  4  Datei kann nicht geschrieben werden
  5  Datei kann nicht erzeugt werden
  7  Zu wenig Speicher verfÅgbar
!end_verbatim

(!I)Beispiel:(!i) (!nl)
!begin_verbatim
VAR Dateiname, Ergebnis;
Dateiname="C:\CLIPBRD\SCRAP.TXT";
Ergebnis=EXPORT(Dateiname, Telefon);
!end_verbatim
Speichert den Inhalt des Feldes (!I)Telefon(!i) auf dem GEM-Klemmbrett ab.

##############################################################
!subnode FIELD

Diese Funktion kann innerhalb der Rechenfunktion verwendet werden, um aus
einer Zeichenkette den Namen eines Feldes  "zusammenzubauen", dessen Inhalt
dann weiterverarbeitet oder dem ein neuer Wert zugewiesen werden kann.
Sinnvoll ist die Verwendung dieser Funktion, wenn Felder einer Tabelle mit
bestimmten Werten vorbelegt werden sollen und sich die Namen dieser Felder
beispielsweise nur in der letzten Stelle durch eine Ziffer unterscheiden.
Sind in Ihrer Tabelle z.B. die Felder FELD1 bis FELD6 enthalten, und Sie
wollen allen Feldern, in die noch kein Wert eingetragen wurde, die Zahl 0
zuweisen, schreiben Sie folgende Rechnung:

!begin_verbatim
VAR i;
i = 0;
WHILE i <= 6 DO
    IF FIELD(  "FELD" + i ) == NULL THEN
        FIELD( "FELD" + i ) = 0;
    END;
    i = i + 1;
END;
!end_verbatim

##############################################################
!subnode FIRST

Ermittelt den kleinsten Wert eines Indexfeldes.

(!U)Syntax:(!u) (!nl)

Ergebnis=FIRST(Indexfeld);

##############################################################
!subnode FLOAT

Wandelt einen beliebigen Wert in eine Flieûkommazahl um.

(!U)Syntax:(!u) (!nl)
Ergebnis=FLOAT(Wert);

Wert ist eine Zeichenkette oder Zahl.

(!I)Beispiel:(!i) (!nl)
FLOAT("012,34") ergibt 12,34.

##############################################################
!subnode Formatieroperator

FÅllt eine Zeichenkette mit Leerzeichen.

(!U)Syntax:(!u) (!nl)

result = string : number;

Die Zeichenkette string wird auf number Zeichen rechtsbÅndig mit
Leerzeichen aufgefÅllt.
Das Ergebnis wird dem Feld oder der Variablen result zugewiesen.

result = string : -number; (!nl)

Die Zeichenkette string wird auf number Zeichen linksbÅndig mit
Leerzeichen aufgefÅllt.
Das Ergebnis wird dem Feld oder der Variablen result zugewiesen oder kann
sofort weiterverwendet werden.

(!I)Beispiel:(!i) (!nl)
NameMitPunkten=REPLACE(Vorname:20," ","."); (!nl)
fÅllt mit Punkten statt mit Blanks auf.


##############################################################
!subnode GET

Holt einen Wert aus einer anderen Tabelle.

(!U)Syntax:(!u) (!nl)
Ergebnis=GET("zu_lesendes_Feld;Quellindex>Zieltabelle.Zielindex");

!begin_ilist
!item [zu_lesendes_Feld] ist der Name des Feldes in der Zieltabelle, dessen Wert
geholt werden soll.

!item [Quellindex] ist der Name des Indexfeldes in der Quelltabelle, Åber das die
Verzweigung erfolgen soll.

!item [Zieltabelle] ist der Name der Tabelle, zu der zu_lesendes_Feld gehîrt.

!item [Zielindex] ist ein Indexfeld der Zieltabelle und bestimmt den Datensatz,
aus dem gelesen werden soll.
!end_ilist

Es wird genau der Datensatz gelesen, in dem Quellindex und Zielindex den
gleichen Wert haben.

(!I)Beispiel:(!i) (!nl)
siehe PUT-Funktion.

##############################################################
!subnode Grundrechenarten:

Die Grundrechenarten dÅrften bekannt sein. + steht fÅr Addition, - fÅr
Subtraktion, * fÅr Multiplikation und / fÅr Division. Diese Operatoren
dÅrfen auf Felder der Datentypen Zahl, Langzahl und Flieûkommazahl ohne
EinschrÑnkungen angewendet werden.

Auf Textfelder und Felder vom Typ Externe Datei ist nur der Operator +
anwendbar. Die Addition zweier Zeichenketten entspricht der
Aneinanderreihung der Zeichenketten.

Auf Datums-, Zeit- und Timestamp-Felder kînnen nur die Operationen
Addition oder Subtraktion angewendet werden. Die Subtraktion zweier
Datumsfelder liefert die Anzahl der Tage zwischen den beiden Daten.
Schaltjahre werden berÅcksichtigt. Das Ergebnis kann einem Feld der
Datentypen Zahl, Langzahl oder Flieûkommazahl zugewiesen werden.
Zu einem Zeitfeld kann sinnvollerweise nur ein anderer Zeitwert addiert
werden. Die Subtraktion zweier Zeitwerte liefert eine Zeitdauer im Format
HHMMSSmmmmmm (das kleine m steht fÅr Mikrosekunden).

Zu einem Feld des Typs TIMESTAMP kînnen Datums-und Zeitfelder addiert
werden. Die Subtraktion zweier TIMESTAMP-Werte liefert eine Zeitdauer im
Format: DDMMYYYYHHMMSSmmmmmm (Tag, Monat, Jahr, Stunden, Minuten,
Sekunden, Mikrosekunden).

##############################################################
!subnode HOUR

Ermittelt aus einem gegebenen Zeitfeld die Stunden.

(!U)Syntax:(!u) (!nl)
Ergebnis=HOUR(Zeitfeld);

(!I)Beispiel:(!i) (!nl)
HOUR(08:36:00) ergibt 8.

##############################################################
!subnode IF-THEN-ELSE

IF-THEN-ELSE-END wird auch als "bedingte Verzweigung" bezeichnet und
ermîglicht es, abhÑngig von logischen Werten bestimmte Operationen
auszufÅhren. Sie kînnen es also von einer Bedingung abhÑngig machen,
welcher Teil der Rechnung ausgefÅhrt werden soll. (!nl)
Die Bedingung ist hinter dem SchlÅsselwort IF zu formulieren. Wenn
die Bedingung zutrifft, der logische Ausdruck also den Wert TRUE besitzt,
werden die Anweisungen ausgefÅhrt, die hinter dem SchlÅsselwort
THEN stehen. (!nl)
ZusÑtzlich kînnen noch weitere Anweisungen hinter dem SchlÅsselwort ELSE
folgen. Diese Anweisungen werden genau dann ausgefÅhrt, wenn die Bedingung
hinter IF nicht zutrifft, der THEN-Zweig also nicht durchlaufen wird.
Dieser ELSE-Zweig kann aber auch weggelassen werden, wenn er nicht
benîtigt wird. Das Ende einer IF-THEN-ELSE-Struktur wird immer durch das
SchlÅsselwort END gekennzeichnet. (!nl)
Es kînnen mehrere IF-THEN-ELSE-END-Strukturen ineinander verschachtelt
werden.

(!I)Beispiel:(!i)
!begin_verbatim
IF RechnungsDatum>FristEnde THEN
    if (RechnungsSumme>500)&(Mahnverfahren==0) THEN
        Mahnverfahren=1;
    END;
    Mahnung=1;
ELSE
    Mahnung=0;
END;
!end_verbatim

(!I)Querverweis:(!i) Logische Operatoren

##############################################################
!subnode IMPORT

Weist einem (beliebiegen) Feld den Inhalt einer Datei zu.

(!U)Syntax:(!u) (!nl)
Ergebnis=IMPORT(Dateiname,Feldname);
!begin_xlist [Dateiname] !short
  !item [Dateiname] ist ein Textfeld oder eine Variable, die einen
        vollstÑndigen Zugriffspfad inklusiv Laufwerksbuchstaben enthÑlt.
  !item [Feldname] ist der Name eines beliebigen Zahlen-, Text-, Grafik-
        oder BLOB-Feldes.
!end_xlist

(!U)Ergebnis(!u)
!begin_verbatim
  0  OK
  1  Datei existiert nicht
  2  Datei kann nicht geîffnet
  3  Datei kann nicht gelesen werden
  6  Datei hat falsches Format
  7  Zu wenig Speicher verfÅgbar
!end_verbatim

(!I)Beispiel:(!i) (!nl)
!begin_verbatim
VAR Dateiname, Ergebnis;
Dateiname="C:\PAPILLON\BILDER\ERDBEERE.IMG";
Ergebnis=EXPORT(Dateiname, BILD);
!end_verbatim
Dabei wird die Datei (!I)ERDBEERE.IMG(!i) in das Grafikfeld (!I)Bild(!i)
importiert.

##############################################################
!subnode KEYCOUNT

Ermittelt, wie oft ein Indexfeld einer (anderen) Tabelle einen bestimmten
Wert enthÑlt.

(!U)Syntax:(!u) (!nl)
Anzahl=KEYCOUNT("Zielindex;Quellindex>Zieltabelle.Zielindex");

Als Ergebnis erhÑlt man, wie oft der SchlÅssel Zielindex in der
Zieltabelle den Wert Wert hat.

(!I)Beispiel:(!i) (!nl)
VAR rechnungen; (!nl)
   rechnungen=KEYCOUNT("KundenNr;KundenNr>RECHNUNGEN.KundenNr"); (!nl)
ermittelt, wie viele Rechnungen fÅr den Kunden KundenNr in der Tabelle
RECHNUNGEN vorhanden sind.

##############################################################
!subnode LAST

Ermittelt den grîûten Wert eines Indexfeldes.

(!U)Syntax:(!u) (!nl)
Ergebnis=LAST(Indexfeld);

(!I)Beispiel:(!i) (!nl)
KundenNummer=LAST(KundenNummer)+1; (!nl)
erzeugt fortlaufende Kundennummern.

##############################################################
!subnode LENGTH

Ermittelt die LÑnge einer Zeichenkette.

(!U)Syntax:(!u) (!nl)
Ergebnis=LENGTH(Zeichenkette);

Zeichenkette ist eine beliebige Zeichenfolge (Konstanter String, Textfeld,
Variable).

(!I)Beispiel:(!i) (!nl)
LENGTH("Hallo") ergibt 5.

##############################################################
!subnode LN

Berechnet den natÅrlichen Logarithmus einer positiven Zahl. Der berechnete
Wert ist der Exponent, mit dem die Zahl e (2,718281...) potenziert werden
muû, damit der angegebene numerische Wert gebildet wird.

(!U)Syntax:(!u) (!nl)
Ergebnis=LN(Wert);

Wert ist eine beliebige positive Zahl (Konstante, Flieûkomma- oder
Zahlenfeld, Variable).

(!I)Beispiel:(!i) (!nl)
LN(7,389056) ergibt 2,0.

##############################################################
!subnode LOG

Berechnet den Zehnerlogarithmus. Der berechnete Wert ist der Exponent, mit
dem die Zahl 10 potenziert werden muû, damit der angegebene numerische
Wert gebildet wird.

(!U)Syntax:(!u) (!nl)
Ergebnis=LOG(Wert);

Wert ist eine beliebige Zahl (Konstante, Flieûkomma-oder Zahlenfeld,
Variable).

(!I)Beispiel:(!i) (!nl)
LOG(10000) ergibt 4,0.

##############################################################
!subnode Logische Operatoren: &, |, !
!label Logische Operatoren

Logische Operatoren werden verwendet, um logische Werte miteinander zu
verknÅpfen. Diese logischen Werte sind TRUE fÅr eine wahre Aussage und
FALSE fÅr eine falsche Aussage.

Der Operator & ist ein logisches AND. Sein Ergebnis ist genau dann TRUE,
wenn beide Operanden den Wert TRUE haben, ansonsten FALSE.

Der Operator | ist ein logisches ODER. Sein Ergebnis ist genau dann FALSE,
wenn beide Operanden den Wert FALSE haben, ansonsten TRUE.

Der logische Operator ! steht fÅr die Negation. Wenn sein Operand den Wert
TRUE besitzt, liefert er FALSE zurÅck, ansonsten TRUE.

Wie die logischen Operatoren verwendet werden, kînnen Sie bei
der Beschreibung der Kontrollstruktur IF-THEN-ELSE-END nachlesen.

##############################################################
!subnode LONG

Wandelt einen beliebigen Wert in eine Langzahl um.

(!U)Syntax:(!u) (!nl)
Ergebnis=LONG(Wert);

Wert ist eine beliebige Zeichenkette, Integer- oder Flieûkommazahl.

(!I)Beispiel:(!i) (!nl)
LONG("012") ergibt die Langzahl 12.

##############################################################
!subnode MAX

Ermittelt fÅr alle DatensÑtze der Zieltabelle, die mit einem bestimmten
Index abgelegt wurden, das Maximum eines beliebigen Feldes.

(!U)Syntax:(!u) (!nl)
Ergebnis=MAX("Feldname;Quellindex>ZIELTABELLE.Zielindex");

Feldname ist das Feld der ZIELTABELLE, fÅr das der grîûte Wert ermittelt
werden soll.

(!I)Beispiel:(!i) (!nl)
VAR pos;
pos=MAX("Position;ReNum>POSITIONEN.ReNum");
ermittelt in der Tabelle POSITIONEN die letzte vergebene Position fÅr die
Rechnungsnummer ReNum.

##############################################################
!subnode MICROSECOND

Ermittelt aus einem Zeitfeld die Anzahl der Mikrosekunden.

(!U)Syntax:(!u) (!nl)
Ergebnis=MICROSECOND(Zeitfeld);

##############################################################
!subnode MIN

Ermittelt fÅr alle DatensÑtze der Zieltabelle, die mit einem bestimmten
Index abgelegt wurden, das Minimum eines beliebigen Feldes.

(!U)Syntax:(!u) (!nl)
Ergebnis=MIN( Feldname;Quellindex>ZIELTABELLE.Zielindex");

Feldname ist das Feld der ZIELTABELLE, fÅr das der kleinste Wert ermittelt
werden soll.

(!I)Beispiel:(!i) (!nl)
siehe MAX.

##############################################################
!subnode MINUTE

Ermittelt aus einem Zeitfeld die Anzahl der Minuten.

(!U)Syntax:(!u) (!nl)
Ergebnis=MINUTE(Zeitfeld);

##############################################################
!subnode MONTH

Ermittelt aus einem Datumsfeld den Monat.

(!U)Syntax:(!u) (!nl)
Ergebnis=MONTH(Datumsfeld);

##############################################################
!subnode NULL

Ein Datenfeld besitzt genau dann den Wert NULL, wenn noch keine Zuweisung
an dieses Feld durchgefÅhrt wurde. Soll der Inhalt eines Feldes gelîscht
werden, kann man dazu die Rechnung

Feldname=NULL;

durchfÅhren.

##############################################################
!subnode POSITION

Sucht eine Zeichenfolge innerhalb einer anderen Zeichenfolge.

(!U)Syntax:(!u) (!nl)
Ergebnis=POSITION(Text, Suchbegriff, Start);

Text ist der zu durchsuchende Text, nach Suchbegriff wird gesucht. Die
Suche startet an der Position Start innerhalb von Text, wobei das erste
Zeichen in Text an Position 0 steht. Wird die gesuchte Zeichenfolge nicht
gefunden, liefert die Funktion den Wert -1 zurÅck.

(!I)Beispiel:(!i) (!nl)
POSITION("PHOENIX ist toll", "ist", 0)
ergibt den Wert 8.

##############################################################
!subnode POW

Potenzfunktion.

(!U)Syntax:(!u) (!nl)
Ergebnis=POW(x,y);

Es wird die y. Potenz von x berechnet.
x und y sind Flieûkommawerte.

(!I)Beispiel:(!i) (!nl)
POW(2,3) ergibt 8.

##############################################################
!subnode PUT

TrÑgt einen Wert in ein Feld einer anderen Tabelle ein.

(!U)Syntax:(!u) (!nl)
Ergebnis=PUT("zu_Ñnderndes_Feld;Quellindex>Zieltabelle.Zielindex",Wert);

!begin_ilist
!item [zu_Ñnderndes_Feld] ist der Name des Feldes in der Zieltabelle, in das der
Wert Wert einzutragen ist.

!item [Quellindex] ist der Name des Indexfeldes in der Quelltabelle, Åber das die
Verzweigung erfolgen soll.

!item [Zieltabelle] ist der Name der Tabelle, zu der zu_Ñnderndes_Feld gehîrt.

!item [Zielindex] ist ein Indexfeld der Zieltabelle und bestimmt den Datensatz,
der geÑndert werden soll.
!end_ilist
Es wird genau der Datensatz geÑndert, in dem
Quellindex und Zielindex den gleichen Wert haben.

Als Beispiel folgt ein Ausschnitt aus einer kleinen Fakturierung mit
Lagerverwaltung. In der Tabelle POSITIONEN werden die einzelnen
Rechnungspositionen erfaût. Dabei wird Åber den SchlÅssel Produktnummer in
den PRODUKTSTAMM verzweigt und dort die Anzahl des verkauften Artikels vom
Lagerbestand abgezogen.

!begin_verbatim
VAR Artikelzahl, Knopf, Ergebnis;
Artikelzahl=GET(
"Lagerbestand;ProduktNr>PRODUKTSTAMM.ProduktNr");
IF Artikelzahl<Anzahl THEN
    Knopf=ALERT(
          "[3][Artikel nicht auf Lager][Abbruch][0|1|1|-1][]");
ELSE
    Ergebnis=PUT(
    "Lagerbestand;ProduktNr>PRODUKTSTAMM.ProduktNr",Artikelzahl-Anzahl);
    IF Ergebnis!=0 THEN
        Knopf=ALERT("[3][Fehler beim PUT-Befehl][~Abbruch][0|1|1|-1][]");
    END;
END;
!end_verbatim

##############################################################
!subnode RANDOM

Zufallsfunktion.

(!U)Syntax:(!u) (!nl)
Ergebnis=RANDOM(Zahl);

Als Ergebnis erhÑlt man eine Zufallszahl im Bereich 0..Zahl-1.

(!I)Beispiel:(!i) (!nl)
RANDOM(1000) ergibt eine Zufallszahl im Bereich 0...999.

##############################################################
!subnode REPEAT-UNTIL

Ist eine Anweisung zur Programmierung einer Schleife. Die Befehle, die
nach REPEAT stehen, werden solange wiederholt, bis der logische Ausdruck
hinter UNTIL den Wert TRUE liefert.
Der Unterschied zu WHILE-DO-END besteht darin, daû die Bedingung erst am
Schleifenende geprÅft wird und die Schleife damit immer mindestens einmal
durchlaufen wird.

(!I)Beispiel:(!i) (!nl)
!begin_verbatim
VAR zaehler, a;
zaehler=1; a=10;
REPEAT
  a=a*10; zaehler=zaehler+1;
UNTIL zaehler>10;
!end_verbatim

Diese Schleife wird zehnmal durchlaufen.

##############################################################
!subnode REPLACE

Zeichenkettenersetzung.

(!U)Syntax:(!u) (!nl)
result = REPLACE(string, pattern, replacement);

In der Zeichenkette string wird die Zeichenfolge pattern durch die unter
replacement angegebene Zeichenfolge ersetzt und das Ergebnis dem Feld
oder der Variablen result zugewiesen.

(!I)Beispiel:(!i) (!nl)
result=REPLACE("Meyer", "ey", "ai"); (!nl)
result enthÑlt dann: Maier

##############################################################
!subnode RETURN

Die Funktion RETURN liefert einen Wert an den grafischen Bericht (siehe
Eigenschaft: Text) zurÅck.

(!U)Syntax:(!u) (!nl)
result=RETURN(Wert);

result muû lediglich aus syntaktischen GrÅnden angegeben werden und kann
eine beliebige Variable bzw. ein beliebiges Feld sein.
Wert wird an den grafischen Bericht Åbergeben.

(!I)Beispiel:(!i) (!nl)
!begin_verbatim
VAR RetVal;
RetVal = GET ("Text;Land>LAND.Land");
IF Original <> "" THEN
  RetVal = RetVal + ' "' + Original + '"';
END;
IF Copyright <> "" THEN
  RetVal = RetVal + " aus dem Jahre " + Copyright;
END;
RetVal = RETURN (RetVal);
!end_verbatim

##############################################################
!subnode ROUND

rundet einen Flieûkommawert auf die nÑchste ganze Zahl.

(!U)Syntax:(!u) (!nl)
Ergebnis=ROUND(Zahl);

Das Ergebnis ist eine Flieûkommazahl.

(!I)Beispiele:(!i) (!nl)
ROUND(15,5) ergibt 16, (!nl)
ROUND(15,5678*100)/100 ergibt 15,57.

##############################################################
!subnode SECOND

Ermittelt aus einem Zeitfeld den Sekundenanteil.

(!U)Syntax:(!u) (!nl)
Ergebnis=SECOND(Zahl);

##############################################################
!subnode SIGN

Ermittelt das Vorzeichen einer Zahl.

(!U)Syntax:(!u) (!nl)
Ergebnis=SIGN(Zahl);

Zahl ist eine beliebige Zahl (Konstante, Flieûkomma- oder Zahlenfeld,
Variable). Je nachdem, ob Zahl negativ, 0 oder positiv ist, wird einer der
Werte -1, 0 oder 1 zurÅckgeliefert.

(!I)Beispiele:(!i) (!nl)
SIGN(-23) ergibt -1. (!nl)
SIGN(0) ergibt 0. (!nl)
SIGN(17,456) ergibt 1.

##############################################################
!subnode SIN

berechnet den Sinus einer Zahl.

(!U)Syntax:(!u) (!nl)
Ergebnis=SIN(Wert);

Wert ist eine beliebige Zahl (Konstante, Flieûkomma- oder Zahlenfeld,
Variable). SIN erwartet einen Wert in der Einheit rad (0 Grad=0*pi, 90
Grad=pi/2, 180 Grad=pi, 270 Grad=3pi/2, 360 Grad=2pi usw.) als Argument und
liefert den dazugehîrigen Sinus zurÅck.

(!I)Beispiel:(!i) (!nl)
SIN(3,141) ergibt 0,0.

##############################################################
!subnode SQRT

Berechnet die Quadratwurzel einer positiven Zahl.

(!U)Syntax:(!u) (!nl)
Ergebnis=SQRT(Wert);

Wert ist eine beliebige Zahl (Konstante, Flieûkomma-oder Zahlenfeld,
Variable).

(!I)Beispiel:(!i) (!nl)
SQRT(400) ergibt 20

##############################################################
!subnode STRLOWER

Verwandelt alle Groûbuchstaben einer Zeichenkette in Kleinbuchstaben.

(!U)Syntax:(!u) (!nl)
Ergebnis=STRLOWER(Zeichenkette);

(!I)Beispiel:(!i) (!nl)
STRLOWER("Das ist ein Test")
ergibt "das ist ein test"

##############################################################
!subnode STRUPPER

Verwandelt alle Kleinbuchstaben einer Zeichenkette in Groûbuchstaben.

(!U)Syntax:(!u) (!nl)
Ergebnis=STRUPPER(Zeichenkette);

(!I)Beispiel:(!i) (!nl)
STRUPPER("Das ist ein Test")
ergibt "DAS IST EIN TEST".

##############################################################
!subnode SUBSTR

Bildet aus einer Zeichenkette einen Teilstring.

(!U)Syntax:(!u) (!nl)
result = SUBSTR(string, position, length);

Aus der Zeichenkette string wird ein Teilstring gebildet. Das erste
Zeichen des Teilstrings steht an der Stelle position in der Zeichenkette
string. Die TeilstringlÑnge wird durch length festgelegt.
Das Ergebnis dieser Funktion wird dem Feld oder der Variablen result
zugewiesen.

(!I)Beispiel:(!i) (!nl)
result=SUBSTR("MANAGER",5,2); (!nl)
result enthÑlt dann: "ER"

##############################################################
!subnode SUM

Ermittelt fÅr alle DatensÑtze der Zieltabelle, die mit einem bestimmten
Index abgelegt wurden, die Summe Åber ein beliebiges Feld.

(!U)Syntax:(!u) (!nl)
Ergebnis=SUM( Feldname;Quellindex>ZIELTABELLE.Zielindex");

Feldname ist das Feld der ZIELTABELLE, das aufsummiert werden soll.

(!I)Beispiel:(!i) (!nl)
VAR Rechnungssumme;
Rechnungssumme=SUM("Preis;ReNum>POSITIONEN.ReNum");

summiert in der Tabelle POSITIONEN das Feld Preis Åber alle DatensÑtze,
die zur Rechnung ReNum existieren.

##############################################################
!subnode SYSDATE

liefert das Systemdatum.

(!U)Syntax:(!u) (!nl)
Datumsfeld=SYSDATE;

##############################################################
!subnode SYSTIME

liefert die Systemzeit.

(!U)Syntax:(!u) (!nl)
Zeitfeld=SYSTIME;

##############################################################
!subnode SYSTIMESTAMP

liefert die Kombination aus Systemdatum und -zeit.

(!U)Syntax:(!u) (!nl)
Timestampfeld=SYSTIMESTAMP;

##############################################################
!subnode TAN

Berechnet den Tangens einer Zahl.

(!U)Syntax:(!u) (!nl)
Ergebnis=TAN(Wert);

Wert ist eine beliebige Zahl (Konstante, Flieûkomma-oder Zahlenfeld,
Variable). TAN erwartet einen Wert in der Einheit rad (0 Grad=0pi, 90
Grad=pi/2, 180 Grad=pi, 270 Grad=3pi/2, 360 Grad=2pi usw.) als Argument und
liefert den dazugehîrigen Tangens zurÅck.

(!I)Beispiel:(!i) (!nl)
TAN(3,141)=-0,000593

##############################################################
!subnode TIME

Konvertiert eine Zeichenkette oder Konstante in ein Zeitfeld.

(!U)Syntax:(!u) (!nl)
Zeitfeld=TIME(Wert);

(!I)Beispiel:(!i) (!nl)
TIME("12:34:05") ergibt 12:34:05.

##############################################################
!subnode TIMESTAMP

Konvertiert eine Zeichenkette oder Konstante in ein Timestampfeld.

(!U)Syntax:(!u) (!nl)
Timestampfeld=TIMESTAMP(Wert);

##############################################################
!subnode TRUNC

KÅrzt eine Flieûkommazahl auf ihren ganzzahligen Teil.

(!U)Syntax:(!u) (!nl)
Ergebnis=TRUNC(Wert);

Die Flieûkommazahl Wert wird auf ihren ganzzahligen Teil gekÅrzt.

(!I)Beispiel:(!i) (!nl)
TRUNC(5,678) ergibt 5,0

##############################################################
!subnode USER

liefert den Namen des aktuellen Datenbankbenutzers als Zeichenkette.

(!U)Syntax:(!u) (!nl)
Ergebnis=USER;

##############################################################
!subnode VAR

Innerhalb einer Rechnung ist es mîglich, bis zu 32 Variablen zu
vereinbaren. Variablen werden wie Felder behandelt. Man kann ihnen Werte
anderer Felder oder Variablen bzw. anderen Feldern ihren Wert zuweisen.
Die Variablen haben keinen bestimmten Datentyp. Sie nehmen automatisch den
Typ des Ausdrucks an, der ihnen zugewiesen wird.

Die Zuweisung a=3 weist der Variablen a die Zahl 3 zu. Die Variable kann
nun wie ein Feld vom Typ Zahl weiterverwendet werden. Variablen sind am
Anfang der Rechnung zu vereinbaren. Das SchlÅsselwort VAR kennzeichnet den
Beginn einer Variablenvereinbarung. In einer Zeile kînnen hinter VAR,
durch Kommata voneinander getrennt, mehrere Variablen deklariert werden.
Erstreckt sich die Variablenvereinbarung Åber mehrere Zeilen, ist VAR am
Anfang jeder Zeile zu schreiben. In Variablennamen wird Groû-
und Kleinschreibung nicht beachtet. Die ersten 15 Zeichen des
Variablennamens werden zur Unterscheidung der Variablen voneinander
verwendet.

##############################################################
!subnode Vergleichsoperatoren: <, <=, ==, >, =>, <>

<  bedeutet kleiner als (!nl)
<= bedeutet kleiner als oder gleich (!nl)
== bedeutet gleich (!nl)
>  bedeutet grîûer als (!nl)
=> bedeutet grîûer als oder gleich (!nl)
<> bedeutet kleiner oder grîûer als (bzw. (!I)nicht(!i) gleich)

Diese Operatoren vergleichen ihre Operanden miteinander. Das
zurÅckgelieferte Ergebnis steht dafÅr, ob die gegebene Bedingung zutrifft
(TRUE, Wert 1) oder nicht (FALSE, Wert 0).

(!I)Example:(!i) (!nl)
Seien FELD1 und FELD2 vom Typ Zahl. FELD1 enthalte den Wert 4 und FELD2 enthalte
den Wert 9. Der AusdruckFELD1<FELD2 liefert demnach genauso wie der
Ausdruck FELD1<=FELD2 den Wert TRUE, wÑhrend FELD1>FELD2 natÅrlich den Wert
FALSE ergibt.

Dabei mÅssen
Sie unbedingt beachten, daû zum Test auf Gleichheit der Operator ==
verwendet wird, da das einfache Gleichheitszeichen schon als
Zuweisungsoperator vergeben ist!

##############################################################
!subnode WHILE-DO-END

Dient zur Programmierung einer Schleife. Die Anweisungen, die hinter dem
SchlÅsselwort DO stehen, werden solange wiederholt, bis der logische
Ausdruck hinter WHILE nicht mehr den Wert TRUE, sondern den Wert FALSE
liefert. (Der Unterschied zu REPEAT-UNTIL, bei dem die Bedingung nur am Ende
der Schleife ÅberprÅft wird. Erfolgt dies bei WHILE zu beginn der Schleife.)

(!I)Beispiel:(!i)
!begin_verbatim
VAR zaehler, a;
zaehler=1; a=10;
WHILE zaehler<=10 DO
  a=a*10; zaehler=zaehler+1;
END;
!end_verbatim

Die Schleife wird genau zehnmal durchlaufen.

##############################################################
!subnode WORD

Wandelt einen beliebigen Wert in eine Integerzahl um (in beim Bereich von
-32767 bis +32767, belegt 2 Byte Speicherplatz).

(!U)Syntax:(!u) (!nl)
Ergebnis=WORD(Wert);

Wert ist eine beliebige Zeichenkette oder Zahl.

(!I)Beispiel:(!i) (!nl)
WORD("012") (!nl)
ergibt 12.

##############################################################
!subnode YEAR

Ermittelt aus einem Datumsfeld das Jahr.

(!U)Syntax:(!u) (!nl)
Ergebnis=YEAR(Datumsfeld);

(!I)Beispiel:(!i) (!nl)
YEAR(Datumsfeld)=YEAR(Datumsfeld)+1;

Addiert ein Jahr zum Datum im (!I)Datumsfeld(!i).

##############################################################
!subnode Zuweisung

Der Zuweisungsoperator ist die grundlegende Operation der Rechen!-funktion.
Er wird verwendet, um der Variablen oder dem Feld auf der linken Seite den
Wert der rechten Seite zuzuweisen.
Zum Beispiel bewirkt SUMME=FELD1+FELD2;, daû dem Feld SUMME das Ergebnis
der Addition der Felder FELD1 und FELD2 zugewiesen wird. Dabei wird immer
versucht, das Ergebnis in den Datentyp des links stehenden Feldes
umzuwandeln. Wird z.B. einem Textfeld eine Zahl zugewiesen, wird diese Zahl
zuerst in eine Zeichenkette konvertiert.
Falls auf der linken Seite der Zuweisung eine Variable steht, nimmt diese
automatisch den Datentyp der rechten Seite an.

